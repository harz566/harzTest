diff --git a/drivers/hv/connection.c b/drivers/hv/connection.c
index 09829e1..ec46b84 100644
--- a/drivers/hv/connection.c
+++ b/drivers/hv/connection.c
@@ -354,9 +354,16 @@ void vmbus_on_event(unsigned long data)
 {
 	struct vmbus_channel *channel = (void *) data;
 	unsigned long time_limit = jiffies + 2;
+	bool test_state = channel->fuzz_testing_state;
+	u32 test_delay = channel->fuzz_testing_buffer_delay;
 
 	trace_vmbus_on_event(channel);
 
+	if (unlikely(test_state)) {
+		if (likely(test_delay > 0))
+			udelay(test_delay);
+	}
+
 	do {
 		void (*callback_fn)(void *);
 
diff --git a/drivers/hv/ring_buffer.c b/drivers/hv/ring_buffer.c
index 9a03b16..bc30e09 100644
--- a/drivers/hv/ring_buffer.c
+++ b/drivers/hv/ring_buffer.c
@@ -395,6 +395,11 @@ struct vmpacket_descriptor *hv_pkt_iter_first(struct vmbus_channel *channel)
 {
 	struct hv_ring_buffer_info *rbi = &channel->inbound;
 	struct vmpacket_descriptor *desc;
+	bool test_state = channel->fuzz_testing_state;
+	u32 test_delay = channel->fuzz_testing_message_delay;
+
+	if (unlikely(test_state && test_delay > 0))
+		udelay(test_delay);
 
 	if (hv_pkt_iter_avail(rbi) < sizeof(struct vmpacket_descriptor))
 		return NULL;
@@ -420,6 +425,11 @@ __hv_pkt_iter_next(struct vmbus_channel *channel,
 	struct hv_ring_buffer_info *rbi = &channel->inbound;
 	u32 packetlen = desc->len8 << 3;
 	u32 dsize = rbi->ring_datasize;
+	bool test_state = channel->fuzz_testing_state;
+	u32 test_delay = channel->fuzz_testing_message_delay;
+
+	if (unlikely(test_state && test_delay > 0))
+		udelay(test_delay);
 
 	/* bump offset to next potential packet */
 	rbi->priv_read_index += packetlen + VMBUS_PKT_TRAILER;
diff --git a/drivers/hv/vmbus_drv.c b/drivers/hv/vmbus_drv.c
index ebd35fc..e0b0c5f 100644
--- a/drivers/hv/vmbus_drv.c
+++ b/drivers/hv/vmbus_drv.c
@@ -23,6 +23,7 @@
 #include <linux/cpu.h>
 #include <linux/sched/task_stack.h>
 
+#include <linux/kernel.h>
 #include <asm/mshyperv.h>
 #include <linux/notifier.h>
 #include <linux/ptrace.h>
@@ -585,6 +586,94 @@ static ssize_t driver_override_show(struct device *dev,
 }
 static DEVICE_ATTR_RW(driver_override);
 
+static ssize_t fuzz_test_state_store(struct device *dev,
+				     struct device_attribute *attr,
+				     const char *buf, size_t count) {
+	struct hv_device *hv_dev = device_to_hv_device(dev);
+	struct vmbus_channel *channel = hv_dev->channel;
+	int val;
+	int delay = kstrtoint(buf, 0, &val);
+
+	if (delay)
+		return count;
+	if (val)
+		channel->fuzz_testing_state = 1;
+	else
+		channel->fuzz_testing_state = 0;
+	return count;
+}
+
+static ssize_t fuzz_test_state_show(struct device *dev,
+				    struct device_attribute *dev_attr,
+				    char *buf)
+{
+	struct hv_device *hv_dev = device_to_hv_device(dev);
+	struct vmbus_channel *channel = hv_dev->channel;
+
+	return sprintf(buf, "%u\n", channel->fuzz_testing_state); } static
+DEVICE_ATTR_RW(fuzz_test_state);
+
+static ssize_t fuzz_test_buffer_delay_store(struct device *dev,
+					    struct device_attribute *attr,
+					    const char *buf, size_t count) {
+	struct hv_device *hv_dev = device_to_hv_device(dev);
+	struct vmbus_channel *channel = hv_dev->channel;
+	int val;
+	int delay = kstrtoint(buf, 0, &val);
+
+	if (delay)
+		return count;
+	if (val >= 1 && val <= 1000)
+		channel->fuzz_testing_buffer_delay = val;
+	/*Best to not use else statement here since we want
+	 *the buffer delay to remain the same if val > 1000
+	 */
+	else if (val <= 0)
+		channel->fuzz_testing_buffer_delay = 0;
+	return count;
+}
+
+static ssize_t fuzz_test_buffer_delay_show(struct device *dev,
+					   struct device_attribute *dev_attr,
+					   char *buf)
+{
+	struct hv_device *hv_dev = device_to_hv_device(dev);
+	struct vmbus_channel *channel = hv_dev->channel;
+
+	return sprintf(buf, "%u\n", channel->fuzz_testing_buffer_delay);
+}
+static DEVICE_ATTR_RW(fuzz_test_buffer_delay);
+
+static ssize_t fuzz_test_message_delay_store(struct device *dev,
+					     struct device_attribute *attr,
+					     const char *buf, size_t count) {
+	struct hv_device *hv_dev = device_to_hv_device(dev);
+	struct vmbus_channel *channel = hv_dev->channel;
+	int val;
+	int delay = kstrtoint(buf, 0, &val);
+
+	if (delay)
+		return count;
+	if (val >= 1 && val <= 1000)
+		channel->fuzz_testing_message_delay = val;
+	/*Best to not use else statement here since we want
+	 *the message delay to remain the same if val > 1000
+	 */
+	else if (val <= 0)
+		channel->fuzz_testing_message_delay = 0;
+	return count;
+}
+
+static ssize_t fuzz_test_message_delay_show(struct device *dev,
+					    struct device_attribute *dev_attr,
+					    char *buf)
+{
+	struct hv_device *hv_dev = device_to_hv_device(dev);
+	struct vmbus_channel *channel = hv_dev->channel;
+
+	return sprintf(buf, "%u\n", channel->fuzz_testing_message_delay);
+}
+static DEVICE_ATTR_RW(fuzz_test_message_delay);
 /* Set up per device attributes in /sys/bus/vmbus/devices/<bus device> */
 static struct attribute *vmbus_dev_attrs[] = {
 	&dev_attr_id.attr,
@@ -616,6 +705,9 @@ static struct attribute *vmbus_dev_attrs[] = {
 	&dev_attr_vendor.attr,
 	&dev_attr_device.attr,
 	&dev_attr_driver_override.attr,
+	&dev_attr_fuzz_test_state.attr,
+	&dev_attr_fuzz_test_buffer_delay.attr,
+	&dev_attr_fuzz_test_message_delay.attr,
 	NULL,
 };
 
diff --git a/include/linux/hyperv.h b/include/linux/hyperv.h
index 6256cc3..b89ffda 100644
--- a/include/linux/hyperv.h
+++ b/include/linux/hyperv.h
@@ -23,6 +23,7 @@
 #include <linux/mod_devicetable.h>
 #include <linux/interrupt.h>
 #include <linux/reciprocal_div.h>
+#include <linux/delay.h>
 
 #define MAX_PAGE_BUFFER_COUNT				32
 #define MAX_MULTIPAGE_BUFFER_COUNT			32 /* 128K */
@@ -926,6 +927,10 @@ struct vmbus_channel {
 	 * full outbound ring buffer.
 	 */
 	u64 out_full_first;
+
+	bool fuzz_testing_state;
+	u32 fuzz_testing_buffer_delay;
+	u32 fuzz_testing_message_delay;
 };
 
 static inline bool is_hvsock_channel(const struct vmbus_channel *c)
